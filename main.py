import os
import re
import random
import logging
import asyncio
import aiohttp
from aiohttp import web
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, ContextTypes,
    CallbackQueryHandler, MessageHandler, filters
)

BOT_TOKEN = os.getenv("BOT_TOKEN")
ADMIN_ID = int(os.getenv("ADMIN_ID"))

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ‡¶∏‡ßç‡¶ü‡ßã‡¶∞‡ßá‡¶ú
free_trial_users = {}
user_sessions = {}  # user_id: {"sid": str, "auth": str}

# ‡¶ï‡¶æ‡¶®‡¶æ‡¶°‡¶æ‡¶∞ ‡¶è‡¶≤‡¶æ‡¶ï‡¶æ ‡¶ï‡ßã‡¶° ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü (30‡¶ü‡¶ø ‡¶∞‚Äç‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶Æ)
CANADA_AREA_CODES = [
    "204", "226", "236", "249", "250", "289", "306", "343", "365",
    "367", "403", "416", "418", "431", "437", "438", "450", "506",
    "514", "519", "548", "579", "581", "587", "604", "613", "639",
    "647", "705", "709"
]

# ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶ú‡ßá‡¶®‡¶æ‡¶∞‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®
def generate_canada_numbers(area_code=None, count=30):
    area_codes = [area_code] if area_code else CANADA_AREA_CODES
    numbers = []
    for _ in range(count):
        ac = random.choice(area_codes)
        # ‡¶ï‡¶æ‡¶®‡¶æ‡¶°‡¶ø‡ßü‡¶æ‡¶® ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü: +1 + AreaCode + 7 digit random number
        number = f"+1{ac}{random.randint(1000000, 9999999)}"
        numbers.append(number)
    return numbers

# ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶•‡ßá‡¶ï‡ßá ‡¶ï‡¶æ‡¶®‡¶æ‡¶°‡¶æ‡¶∞ ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∞‡ßá‡¶ó‡ßÅ‡¶≤‡¶æ‡¶∞ ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡ßç‡¶∞‡ßá‡¶∂‡¶®
CANADA_NUMBER_REGEX = re.compile(r"(?:\+?1)?(204|226|236|249|250|289|306|343|365|367|403|416|418|431|437|438|450|506|514|519|548|579|581|587|604|613|639|647|705|709)[-\s]?(\d{3})[-\s]?(\d{4})")

# ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶•‡ßá‡¶ï‡ßá ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü ‡¶†‡¶ø‡¶ï ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®
def extract_canada_numbers_from_text(text):
    found_numbers = []
    for match in CANADA_NUMBER_REGEX.finditer(text):
        area = match.group(1)
        part2 = match.group(2)
        part3 = match.group(3)
        full_number = f"+1{area}{part2}{part3}"
        found_numbers.append(full_number)
    return list(set(found_numbers))  # ‡¶á‡¶â‡¶®‡¶ø‡¶ï ‡¶ï‡¶∞‡ßá ‡¶∞‡¶ø‡¶ü‡¶æ‡¶∞‡ßç‡¶®

# Twilio API ‡¶¶‡¶ø‡ßü‡ßá ‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶®‡ßç‡¶∏ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®
async def check_twilio_balance(sid, auth):
    async with aiohttp.ClientSession(auth=aiohttp.BasicAuth(sid, auth)) as session:
        account_url = "https://api.twilio.com/2010-04-01/Accounts.json"
        async with session.get(account_url) as resp:
            if resp.status == 401:
                return "suspended", None
            if resp.status != 200:
                return "error", None
            data = await resp.json()
            account_name = data['accounts'][0]['friendly_name']

        balance_url = f"https://api.twilio.com/2010-04-01/Accounts/{sid}/Balance.json"
        async with session.get(balance_url) as bresp:
            if bresp.status != 200:
                return "error", None
            balance_data = await bresp.json()
            balance = float(balance_data.get("balance", 0.0))
            return "ok", (account_name, balance)

# ‡¶∏‡ßç‡¶ü‡¶æ‡¶∞‡ßç‡¶ü ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶°
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_name = update.effective_user.full_name
    username = update.effective_user.username or "N/A"

    if free_trial_users.get(user_id) == "active":
        keyboard = [[InlineKeyboardButton("Login üîë", callback_data="login")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(f"{user_name} Subscription ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶Ü‡¶õ‡ßá ‡¶è‡¶¨‡¶æ‡¶∞ Log In ‡¶ï‡¶∞‡ßÅ‡¶®", reply_markup=reply_markup)
        return

    keyboard = [
        [InlineKeyboardButton("‚¨ú 1 Hour - Free üå∏", callback_data="plan_free")],
        [InlineKeyboardButton("üî¥ 1 Day - 2$", callback_data="plan_1d")],
        [InlineKeyboardButton("üü† 7 Day - 10$", callback_data="plan_7d")],
        [InlineKeyboardButton("üü° 15 Day - 15$", callback_data="plan_15d")],
        [InlineKeyboardButton("üü¢ 30 Day - 20$", callback_data="plan_30d")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Welcome {user_name} üå∏\n‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡ßã‡¶®‡¶ü‡¶ø ‡¶®‡¶ø‡¶§‡ßá ‡¶ö‡¶æ‡¶ö‡ßç‡¶õ‡ßá‡¶®..?", reply_markup=reply_markup)

# ‡¶≤‡¶ó‡¶á‡¶® ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶°
async def login_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if free_trial_users.get(user_id) == "active":
        keyboard = [[InlineKeyboardButton("Login üîë", callback_data="login")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Subscription ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶Ü‡¶õ‡ßá, ‡¶®‡¶ø‡¶ö‡ßá Login ‡¶ï‡¶∞‡ßÅ‡¶® ‚¨áÔ∏è", reply_markup=reply_markup)
    else:
        await update.message.reply_text("‚ùå ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Subscription ‡¶®‡ßá‡¶á‡•§ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá Subscription ‡¶®‡¶ø‡¶®‡•§")

# Callback ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶æ‡¶∞
async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    user_name = query.from_user.full_name
    username = query.from_user.username or "N/A"

    if query.data == "plan_free":
        if free_trial_users.get(user_id):
            await query.edit_message_text("‚ö†Ô∏è ‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶∞‡¶á ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá Free Trial ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡¶õ‡ßá‡¶®‡•§")
        else:
            free_trial_users[user_id] = "active"
            await query.message.delete()
            await context.bot.send_message(chat_id=user_id, text="‚úÖ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Free Trial Subscription ‡¶ü‡¶ø ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶π‡ßü‡ßá‡¶õ‡ßá")

            async def revoke():
                await asyncio.sleep(3600)
                free_trial_users.pop(user_id, None)
                await context.bot.send_message(chat_id=user_id, text="üåª ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Free Trial ‡¶ü‡¶ø ‡¶∂‡ßá‡¶∑ ‡¶π‡ßü‡ßá‡¶õ‡ßá")
            asyncio.create_task(revoke())

    elif query.data.startswith("plan_"):
        plan_info = {
            "plan_1d": ("1 Day", "2$"),
            "plan_7d": ("7 Day", "10$"),
            "plan_15d": ("15 Day", "15$"),
            "plan_30d": ("30 Day", "20$")
        }
        duration, price = plan_info.get(query.data, ("", ""))

        text = (
            f"{user_name} {duration} ‡¶∏‡¶Æ‡ßü‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø Subscription ‡¶®‡¶ø‡¶§‡ßá ‡¶ö‡¶æ‡¶ö‡ßç‡¶õ‡ßá‡•§\n\n"
            f"üîÜ User Name : {user_name}\n"
            f"üîÜ User ID : {user_id}\n"
            f"üîÜ Username : @{username}"
        )
        buttons = [
            [InlineKeyboardButton("APPROVE ‚úÖ", callback_data=f"approve_{user_id}"),
             InlineKeyboardButton("CANCEL ‚ùå", callback_data=f"cancel_{user_id}")]
        ]
        reply_markup = InlineKeyboardMarkup(buttons)

        await query.message.delete()
        await context.bot.send_message(chat_id=ADMIN_ID, text=text, reply_markup=reply_markup)

        payment_msg = (
            f"Please send {price} to Binance Pay ID: \n‡¶™‡ßá‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡ßá ‡¶™‡ßç‡¶∞‡¶Æ‡¶æ‡¶£ ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá Admin ‡¶è‡¶∞ ‡¶ï‡¶æ‡¶õ‡ßá ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶®‡¶∂‡¶ü ‡¶Ö‡¶•‡¶¨‡¶æ transaction ID ‡¶¶‡¶ø‡¶® @Mr_Evan3490\n\n"
            f"Your payment details:\n"
            f"üÜî User ID: {user_id}\n"
            f"üë§ Username: @{username}\n"
            f"üìã Plan: {duration}\n"
            f"üí∞ Amount: {price}"
        )
        await context.bot.send_message(chat_id=user_id, text=payment_msg)

    elif query.data == "login":
        await context.bot.send_message(chat_id=user_id, text="‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Sid ‡¶è‡¶¨‡¶Ç Auth Token ‡¶¶‡¶ø‡¶® üéâ\n\n‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶π‡¶¨‡ßá: `<sid> <auth>`", parse_mode='Markdown')

    elif query.data.startswith("approve_"):
        uid = int(query.data.split("_")[1])
        free_trial_users[uid] = "active"
        await context.bot.send_message(chat_id=uid, text="‚úÖ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Subscription ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá")
        await query.edit_message_text("‚úÖ Approve ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶è‡¶¨‡¶Ç Permission ‡¶¶‡ßá‡¶ì‡ßü‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§")

    elif query.data.startswith("cancel_"):
        await query.edit_message_text("‚ùå Subscription Request ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§")

    elif query.data.startswith("buy_"):
        # buy_ ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶•‡ßá‡¶ï‡ßá ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶®‡ßá‡¶¨‡ßã
        buy_number = query.data[4:]
        sid_auth = user_sessions.get(user_id)
        if not sid_auth:
            await query.answer("‚ùå ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá ‡¶≤‡¶ó‡¶á‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
            return
        sid, auth = sid_auth["sid"], sid_auth["auth"]

        # ‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶®‡ßç‡¶∏ ‡¶ö‡ßá‡¶ï
        status, bal_data = await check_twilio_balance(sid, auth)
        if status == "suspended":
            await query.answer("‡¶ü‡ßã‡¶ï‡ßá‡¶® Suspend ‡¶π‡ßü‡ßá‡¶õ‡ßá üò• ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶® ‚ôªÔ∏è", show_alert=True)
            return
        elif status != "ok":
            await query.answer("‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶®‡ßç‡¶∏ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§ ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§", show_alert=True)
            return

        account_name, balance = bal_data
        cost_per_number = 1.0  # ‡¶ß‡¶∞‡¶≤‡¶æ‡¶Æ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞‡ßá‡¶∞ ‡¶¶‡¶æ‡¶Æ 1$

        if balance < cost_per_number:
            await query.answer("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ü‡ßã‡¶ï‡ßá‡¶®‡ßá ‡¶™‡¶∞‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶§ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶®‡ßç‡¶∏ ‡¶®‡¶æ‡¶á üò• ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶® ‚ôªÔ∏è", show_alert=True)
            return

        # ‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶®‡ßç‡¶∏ ‡¶Ü‡¶õ‡ßá, ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶ï‡¶ø‡¶®‡ßá ‡¶´‡ßá‡¶≤‡¶æ ‡¶π‡¶≤‡ßã
        # ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶Ü‡¶™‡¶®‡¶ø Twilio API ‡¶¶‡¶ø‡ßü‡ßá ‡¶™‡ßç‡¶∞‡¶ï‡ßÉ‡¶§ ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶ï‡ßç‡¶∞‡ßü ‡¶≤‡¶ú‡¶ø‡¶ï ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶¨‡ßá‡¶®

        # ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶è‡¶°‡¶ø‡¶ü
        new_text = (
            f"üéâ Congestion ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞‡¶ü‡¶ø ‡¶ï‡¶ø‡¶®‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá üéâ\n\n"
            f"‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞: {buy_number}"
        )
        # ‡¶®‡¶§‡ßÅ‡¶® ‡¶¨‡¶æ‡¶ü‡¶®
        keyboard = [[InlineKeyboardButton("Message ‚úâÔ∏è", callback_data=f"msg_{buy_number}")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(new_text, reply_markup=reply_markup)

    elif query.data.startswith("msg_"):
        buy_number = query.data[4:]
        await query.answer(f"‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶ñ‡¶® ‡¶è‡¶á ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞‡ßá ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶™‡¶æ‡¶†‡¶æ‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá‡¶®: {buy_number}", show_alert=True)

# ‡¶á‡¶â‡¶ú‡¶æ‡¶∞‡ßá‡¶∞ ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶≤‡ßã‡¶ó‡¶á‡¶® ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶æ‡¶∞
async def handle_sid_auth(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if free_trial_users.get(user_id) != "active":
        return

    try:
        sid, auth = update.message.text.strip().split(" ", 1)
    except:
        await update.message.reply_text("‚ö†Ô∏è ‡¶∏‡¶†‡¶ø‡¶ï‡¶≠‡¶æ‡¶¨‡ßá Sid ‡¶è‡¶¨‡¶Ç Auth ‡¶¶‡¶ø‡¶®, ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£: `<sid> <auth>`", parse_mode='Markdown')
        return

    status, bal_data = await check_twilio_balance(sid, auth)
    if status == "suspended":
        await update.message.reply_text("üéÉ ‡¶ü‡ßã‡¶ï‡ßá‡¶® Suspend ‡¶π‡ßü‡ßá ‡¶ó‡ßá‡¶õ‡ßá ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®")
        return
    if status != "ok":
        await update.message.reply_text("‚ùå ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§ ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
        return

    account_name, balance = bal_data
    user_sessions[user_id] = {"sid": sid, "auth": auth}

    await update.message.reply_text(
        f"üéâ ùêãùê®ùê† ùêàùêß ùêíùêÆùêúùêúùêûùê¨ùê¨ùêüùêÆùê•üéâ\n\n"
        f"‚≠ï ùóîùó∞ùó∞ùóºùòÇùóªùòÅ ùó°ùóÆùó∫ùó≤ : {account_name}\n"
        f"‚≠ï ùóîùó∞ùó∞ùóºùòÇùóªùòÅ ùóïùóÆùóπùóÆùóªùó∞ùó≤ : ${balance:.2f}\n\n"
        f"‡¶¨‡¶ø‡¶É‡¶¶‡ßç‡¶∞‡¶É  ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶ï‡¶ø‡¶®‡¶æ‡¶∞ ‡¶Ü‡¶ó‡ßá ‡¶Ö‡¶¨‡¶∂‡ßç‡¶Ø‡¶á ùóïùóÆùóπùóÆùóªùó∞ùó≤ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßá ‡¶®‡¶ø‡¶¨‡ßá‡¶® ‡¶ï‡¶Æ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶®‡ßç‡¶∏ ‡¶•‡¶æ‡¶ï‡¶≤‡ßá ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶ï‡¶ø‡¶®‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá ‡¶®‡¶æ ‚ôªÔ∏è\n\n"
        f"Founded By ùó†ùóø ùóòùòÉùóÆùóª üçÅ"
    )

# /buy ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶æ‡¶∞
async def buy_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if free_trial_users.get(user_id) != "active":
        await update.message.reply_text("‚ùå ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Subscription ‡¶®‡ßá‡¶á‡•§ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá ‡¶≤‡¶ó‡¶á‡¶® ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶Ö‡¶•‡¶¨‡¶æ Subscription ‡¶®‡¶ø‡¶®‡•§")
        return

    args = context.args
    area_code = None
    if args:
        code = args[0]
        # ‡¶è‡¶≤‡¶æ‡¶ï‡¶æ ‡¶ï‡ßã‡¶° ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶Ø‡¶¶‡¶ø ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü‡ßá ‡¶•‡¶æ‡¶ï‡ßá
        if code in CANADA_AREA_CODES:
            area_code = code
        else:
            await update.message.reply_text("‚ö†Ô∏è ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶¨‡ßà‡¶ß ‡¶ï‡¶æ‡¶®‡¶æ‡¶°‡¶æ‡¶∞ ‡¶è‡¶∞‡¶ø‡ßü‡¶æ ‡¶ï‡ßã‡¶° ‡¶¶‡¶ø‡¶®‡•§")
            return

    numbers = generate_canada_numbers(area_code)

    # ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞‡¶ó‡ßÅ‡¶≤‡ßã ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®
    msg_text = "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶π‡¶≤‡ßã üëáüëá\n"
    for n in numbers:
        msg_text += n + "\n"

    await update.message.reply_text(msg_text)

# ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶•‡ßá‡¶ï‡ßá ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶°‡¶ø‡¶ü‡ßá‡¶ï‡¶∂‡¶® ‡¶ì ‡¶¨‡¶æ‡¶ü‡¶® ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶° ‡¶ï‡¶∞‡¶æ
async def handle_numbers_with_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if free_trial_users.get(user_id) != "active":
        return

    text = update.message.text
    found_numbers = extract_canada_numbers_from_text(text)
    if not found_numbers:
        return  # ‡¶ï‡ßã‡¶® ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü ‡¶®‡¶ø

    # ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡¶æ‡¶ü‡¶® ‡¶¨‡¶æ‡¶®‡¶æ‡¶®‡ßã
    buttons = []
    for num in found_numbers:
        buttons.append([InlineKeyboardButton("Buy üí∞", callback_data=f"buy_{num}")])

    reply_markup = InlineKeyboardMarkup(buttons)
    await update.message.reply_text("\n".join(found_numbers), reply_markup=reply_markup)

async def handle_update(request):
    data = await request.json()
    update = Update.de_json(data, application.bot)
    await application.update_queue.put(update)
    return web.Response(text="OK")

application = Application.builder().token(BOT_TOKEN).build()
application.add_handler(CommandHandler("start", start))
application.add_handler(CommandHandler("login", login_command))
application.add_handler(CommandHandler("buy", buy_command))
application.add_handler(CallbackQueryHandler(handle_callback))
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_sid_auth))
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_numbers_with_buttons))

async def main():
    await application.initialize()
    await application.start()
    app = web.Application()
    app.router.add_post(f"/{BOT_TOKEN}", handle_update)
    runner = web.AppRunner(app)
    await runner.setup()
    port = int(os.environ.get("PORT", 10000))
    site = web.TCPSite(runner, "0.0.0.0", port)
    await site.start()
    logger.info("Bot is running via webhook...")
    await asyncio.Event().wait()

if __name__ == "__main__":
    asyncio.run(main())
