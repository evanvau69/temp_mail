import os
import logging
import asyncio
import aiohttp
from aiohttp import web
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, ContextTypes, CallbackQueryHandler,
    MessageHandler, filters
)
import re
import random

BOT_TOKEN = os.getenv("BOT_TOKEN")
ADMIN_ID = int(os.getenv("ADMIN_ID"))

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

free_trial_users = {}
user_sessions = {}
allowed_users = set()  # ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶Ø‡¶æ‡¶¶‡ßá‡¶∞ ‡¶™‡¶æ‡¶∞‡¶Æ‡¶ø‡¶∂‡¶® ‡¶¶‡¶ø‡¶¨‡ßá

CANADA_AREA_CODES = [
    "204", "236", "249", "250", "289", "306", "343", "365", "387", "403",
    "416", "418", "431", "437", "438", "450", "506", "514", "519", "548",
    "579", "581", "587", "604", "613", "639", "647", "672", "705", "709",
    "742", "778", "780", "782", "807", "819", "825", "867", "873", "902", "905"
]

def generate_random_numbers(area_code=None, count=30):
    numbers = []
    if area_code and area_code not in CANADA_AREA_CODES:
        return []
    for _ in range(count):
        ac = area_code if area_code else random.choice(CANADA_AREA_CODES)
        # Generate a random 7 digit number after area code
        number = f"+1{ac}{random.randint(1000000, 9999999)}"
        numbers.append(number)
    return numbers

def extract_canada_numbers(text):
    # Regex to find numbers with/without +, optional spaces etc
    pattern = r"(?:\+?1)?(204|236|249|250|289|306|343|365|387|403|416|418|431|437|438|450|506|514|519|548|579|581|587|604|613|639|647|672|705|709|742|778|780|782|807|819|825|867|873|902|905)\D*(\d{3})\D*(\d{4})"
    matches = re.findall(pattern, text)
    result = []
    for match in matches:
        number = "+1" + "".join(match)
        result.append(number)
    return result

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_name = update.effective_user.full_name

    if free_trial_users.get(user_id) == "active" or user_id in allowed_users:
        keyboard = [[InlineKeyboardButton("Login üîë", callback_data="login")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            f"{user_name} Subscription ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶Ü‡¶õ‡ßá ‡¶è‡¶¨‡¶æ‡¶∞ Log In ‡¶ï‡¶∞‡ßÅ‡¶®", reply_markup=reply_markup)
    else:
        keyboard = [
            [InlineKeyboardButton("‚¨ú 1 Hour - Free üå∏", callback_data="plan_free")],
            [InlineKeyboardButton("üî¥ 1 Day - 2$", callback_data="plan_1d")],
            [InlineKeyboardButton("üü† 7 Day - 10$", callback_data="plan_7d")],
            [InlineKeyboardButton("üü° 15 Day - 15$", callback_data="plan_15d")],
            [InlineKeyboardButton("üü¢ 30 Day - 20$", callback_data="plan_30d")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            f"Welcome {user_name} üå∏\n‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡ßã‡¶®‡¶ü‡¶ø ‡¶®‡¶ø‡¶§‡ßá ‡¶ö‡¶æ‡¶ö‡ßç‡¶õ‡ßá‡¶®..?", reply_markup=reply_markup)

async def login_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if free_trial_users.get(user_id) == "active" or user_id in allowed_users:
        keyboard = [[InlineKeyboardButton("Login üîë", callback_data="login")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Subscription ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶Ü‡¶õ‡ßá, ‡¶®‡¶ø‡¶ö‡ßá Login ‡¶ï‡¶∞‡ßÅ‡¶® ‚¨áÔ∏è", reply_markup=reply_markup)
    else:
        await update.message.reply_text("‚ùå ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Subscription ‡¶®‡ßá‡¶á‡•§ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá Subscription ‡¶®‡¶ø‡¶®‡•§")

async def buy_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if free_trial_users.get(user_id) != "active" and user_id not in allowed_users:
        await update.message.reply_text("‚ùå ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Subscription ‡¶®‡ßá‡¶á‡•§ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá Subscription ‡¶®‡¶ø‡¶®‡•§")
        return

    args = context.args
    area_code = None
    if args:
        candidate = args[0]
        if candidate.isdigit() and candidate in CANADA_AREA_CODES:
            area_code = candidate

    numbers = generate_random_numbers(area_code)
    if not numbers:
        await update.message.reply_text("‚ö†Ô∏è ‡¶∏‡¶†‡¶ø‡¶ï Canada Area Code ‡¶¶‡¶ø‡¶®‡•§")
        return

    msg_text = "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶π‡¶≤‡ßã üëáüëá\n" + "\n".join(numbers)
    await update.message.reply_text(msg_text)

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    user_name = query.from_user.full_name
    username = query.from_user.username or "N/A"

    if query.data == "plan_free":
        if free_trial_users.get(user_id):
            await query.edit_message_text("‚ö†Ô∏è ‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶∞‡¶á ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá Free Trial ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡¶õ‡ßá‡¶®‡•§")
        else:
            free_trial_users[user_id] = "active"
            await query.message.delete()
            await context.bot.send_message(chat_id=user_id, text="‚úÖ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Free Trial Subscription ‡¶ü‡¶ø ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶π‡ßü‡ßá‡¶õ‡ßá")

            async def revoke():
                await asyncio.sleep(3600)
                free_trial_users.pop(user_id, None)
                await context.bot.send_message(chat_id=user_id, text="üåª ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Free Trial ‡¶ü‡¶ø ‡¶∂‡ßá‡¶∑ ‡¶π‡ßü‡ßá‡¶õ‡ßá")
            asyncio.create_task(revoke())

    elif query.data.startswith("plan_") and query.data != "plan_free":
        plan_info = {
            "plan_1d": ("1 Day", "2"),
            "plan_7d": ("7 Day", "10"),
            "plan_15d": ("15 Day", "15"),
            "plan_30d": ("30 Day", "20")
        }
        duration, price = plan_info.get(query.data, ("", ""))

        text = (
            f"{user_name} {duration} ‡¶∏‡¶Æ‡ßü‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø Subscription ‡¶®‡¶ø‡¶§‡ßá ‡¶ö‡¶æ‡¶ö‡ßç‡¶õ‡ßá‡•§\n\n"
            f"üîÜ User Name : {user_name}\n"
            f"üîÜ User ID : {user_id}\n"
            f"üîÜ Username : @{username}"
        )
        buttons = [
            [InlineKeyboardButton("APPROVE ‚úÖ", callback_data=f"approve_{user_id}"),
             InlineKeyboardButton("CANCEL ‚ùå", callback_data=f"cancel_{user_id}")]
        ]
        reply_markup = InlineKeyboardMarkup(buttons)

        await query.message.delete()
        await context.bot.send_message(chat_id=ADMIN_ID, text=text, reply_markup=reply_markup)

        payment_msg = (
            f"Please send ${price} to Binance Pay ID: \n"
            f"‡¶™‡ßá‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡ßá ‡¶™‡ßç‡¶∞‡¶Æ‡¶æ‡¶® ‡¶π‡¶ø‡¶∏‡¶æ‡¶¨‡ßá Admin ‡¶è‡¶∞ ‡¶ï‡¶æ‡¶õ‡ßá ‡¶∏‡ßç‡¶ï‡¶ø‡¶®‡¶∂‡¶∞‡ßç‡¶ü ‡¶Ö‡¶•‡¶¨‡¶æ transaction ID ‡¶¶‡¶ø‡¶® @Mr_Evan3490\n\n"
            f"Your payment details:\n"
            f"üÜî User ID: {user_id}\n"
            f"üë§ Username: @{username}\n"
            f"üìã Plan: {duration}\n"
            f"üí∞ Amount: ${price}"
        )
        await context.bot.send_message(chat_id=user_id, text=payment_msg)

    elif query.data == "login":
        await context.bot.send_message(
            chat_id=user_id,
            text="‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Sid ‡¶è‡¶¨‡¶Ç Auth Token ‡¶¶‡¶ø‡¶® üéâ\n\n‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶π‡¶¨‡ßá: `<sid> <auth>`",
            parse_mode='Markdown'
        )

    elif query.data.startswith("approve_"):
        uid = int(query.data.split("_")[1])
        free_trial_users[uid] = "active"
        allowed_users.add(uid)
        await context.bot.send_message(chat_id=uid, text="‚úÖ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Subscription ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá")
        await query.edit_message_text("‚úÖ Approve ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶è‡¶¨‡¶Ç Permission ‡¶¶‡ßá‡¶ì‡ßü‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§")

    elif query.data.startswith("cancel_"):
        await query.edit_message_text("‚ùå Subscription Request ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§")

    elif query.data.startswith("buy_"):
        number = query.data[4:]
        text = f"‡¶Ü‡¶™‡¶®‡¶ø ‡¶¨‡ßá‡¶õ‡ßá ‡¶®‡¶ø‡ßü‡ßá‡¶õ‡ßá‡¶®: {number}"
        buttons = [[InlineKeyboardButton("Buy üí∞", callback_data=f"confirmbuy_{number}")]]
        reply_markup = InlineKeyboardMarkup(buttons)
        await query.edit_message_text(text, reply_markup=reply_markup)

    elif query.data.startswith("confirmbuy_"):
        number = query.data[11:]
        uid = query.from_user.id

        # Check permission and balance before buy (simulate)
        if free_trial_users.get(uid) != "active" and uid not in allowed_users:
            await context.bot.send_message(chat_id=uid, text="‚ùå ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Subscription ‡¶®‡ßá‡¶á‡•§")
            return

        sid_auth = user_sessions.get(uid)
        if not sid_auth:
            await context.bot.send_message(chat_id=uid, text="‚ùå ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá Login ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
            return

        sid, auth = sid_auth
        async with aiohttp.ClientSession(auth=aiohttp.BasicAuth(sid, auth)) as session:
            balance_resp = await session.get(f"https://api.twilio.com/2010-04-01/Accounts/{sid}/Balance.json")
            if balance_resp.status == 401:
                await context.bot.send_message(chat_id=uid, text="‡¶ü‡ßã‡¶ï‡ßá‡¶® Suspend ‡¶π‡ßü‡ßá‡¶õ‡ßá üò• ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶® ‚ôªÔ∏è")
                return
            balance_data = await balance_resp.json()
            balance = float(balance_data.get("balance", 0.0))

            # Simulate price 1$
            price = 1.0
            if balance < price:
                await context.bot.send_message(chat_id=uid, text="‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ü‡ßã‡¶ï‡ßá‡¶®‡ßá ‡¶™‡¶∞‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶§ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶®‡ßç‡¶∏ ‡¶®‡¶æ‡¶á üò• ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶® ‚ôªÔ∏è")
                return

            # Simulate purchase success
            # Here you would call Twilio API to buy number - skipped for demo
            text = (
                f"üéâ Congestion ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞‡¶ü‡¶ø ‡¶ï‡¶ø‡¶®‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá üéâ\n\n"
                f"‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶ü‡¶æ ‡¶•‡¶æ‡¶ï‡¶¨‡ßá {number}"
            )
            buttons = [[InlineKeyboardButton("Message ‚úâÔ∏è", callback_data=f"message_{number}")]]
            reply_markup = InlineKeyboardMarkup(buttons)

            await query.edit_message_text(text, reply_markup=reply_markup)

    elif query.data.startswith("message_"):
        number = query.data[8:]
        await query.answer("Message feature ‡¶è‡¶ñ‡¶®‡ßã ‡¶®‡ßá‡¶á", show_alert=True)

async def handle_sid_auth(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    text = update.message.text.strip()

    if free_trial_users.get(user_id) != "active" and user_id not in allowed_users:
        await update.message.reply_text("‚ùå ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Subscription ‡¶®‡ßá‡¶á‡•§")
        return

    try:
        sid, auth = text.split(" ", 1)
    except:
        await update.message.reply_text("‚ö†Ô∏è ‡¶∏‡¶†‡¶ø‡¶ï‡¶≠‡¶æ‡¶¨‡ßá Sid ‡¶è‡¶¨‡¶Ç Auth ‡¶¶‡¶ø‡¶®, ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£: `<sid> <auth>`", parse_mode='Markdown')
        return

    async with aiohttp.ClientSession(auth=aiohttp.BasicAuth(sid, auth)) as session:
        account_resp = await session.get("https://api.twilio.com/2010-04-01/Accounts.json")
        if account_resp.status == 401:
            await update.message.reply_text("üéÉ ‡¶ü‡ßã‡¶ï‡ßá‡¶® Suspend ‡¶π‡ßü‡ßá ‡¶ó‡ßá‡¶õ‡ßá ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®")
            return
        data = await account_resp.json()
        account_name = data['accounts'][0]['friendly_name']

        balance_resp = await session.get(f"https://api.twilio.com/2010-04-01/Accounts/{sid}/Balance.json")
        balance_data = await balance_resp.json()
        balance = float(balance_data.get("balance", 0.0))

        await update.message.reply_text(
            f"üéâ ùêãùê®ùê† ùêàùêß ùêíùêÆùêúùêúùêûùê¨ùê¨ùêüùêÆùê•üéâ\n\n"
            f"‚≠ï ùóîùó∞ùó∞ùóºùòÇùóªùòÅ ùó°ùóÆùó∫ùó≤ : {account_name}\n"
            f"‚≠ï ùóîùó∞ùó∞ùóºùòÇùóªùòÅ ùóïùóÆùóπùóÆùóªùó∞ùó≤ : ${balance:.2f}\n\n"
            f"‡¶¨‡¶ø‡¶É‡¶¶‡ßç‡¶∞‡¶É  ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶ï‡¶ø‡¶®‡¶æ‡¶∞ ‡¶Ü‡¶ó‡ßá ‡¶Ö‡¶¨‡¶∂‡ßç‡¶Ø‡¶á ùóïùóÆùóπùóÆùóªùó∞ùó≤ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßá ‡¶®‡¶ø‡¶¨‡ßá‡¶® ‡¶ï‡¶Æ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶®‡ßç‡¶∏ ‡¶•‡¶æ‡¶ï‡¶≤‡ßá ‡¶®‡¶æ‡¶Æ‡ßç‡¶¨‡¶æ‡¶∞ ‡¶ï‡¶ø‡¶®‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá ‡¶®‡¶æ ‚ôªÔ∏è\n\n"
            f"Founded By ùó†ùóø ùóòùòÉùóÆùóª üçÅ"
        )
        user_sessions[user_id] = (sid, auth)

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if free_trial_users.get(user_id) != "active" and user_id not in allowed_users:
        await update.message.reply_text("‚ùå ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Subscription ‡¶®‡ßá‡¶á‡•§")
        return

    text = update.message.text
    numbers = extract_canada_numbers(text)
    if not numbers:
        await update.message.reply_text("‚ö†Ô∏è ‡¶ï‡ßã‡¶® Canada ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§ ‡¶¶‡ßü‡¶æ ‡¶ï‡¶∞‡ßá ‡¶∏‡¶†‡¶ø‡¶ï ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡•§")
        return

    for num in numbers:
        keyboard = [[InlineKeyboardButton("Buy üí∞", callback_data=f"buy_{num}")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(num, reply_markup=reply_markup)

async def approve_cancel_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # ‡¶è‡¶á ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶æ‡¶∞ callback query ‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø
    pass  # ‡¶Ü‡¶ó‡ßá‡¶á handle_callback ‡¶è ‡¶Ü‡¶õ‡ßá

async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE):
    logger.error(msg="Exception while handling an update:", exc_info=context.error)
    try:
        await update.message.reply_text("‚ö†Ô∏è ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá, ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
    except:
        pass

async def webhook_handler(request):
    if request.method == "POST":
        data = await request.json()
        update = Update.de_json(data, application.bot)
        await application.update_queue.put(update)
        return web.Response(text="ok")
    else:
        return web.Response(status=405)

if __name__ == "__main__":
    application = Application.builder().token(BOT_TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("login", login_command))
    application.add_handler(CommandHandler("buy", buy_command))
    application.add_handler(CallbackQueryHandler(handle_callback))
    application.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), handle_text))
    application.add_handler(MessageHandler(filters.Regex(r"^[a-zA-Z0-9]{34} [a-zA-Z0-9]{32}$"), handle_sid_auth))

    application.add_error_handler(error_handler)

    # Webhook setup
    WEBHOOK_URL = os.getenv("WEBHOOK_URL")
    if not WEBHOOK_URL:
        logger.error("WEBHOOK_URL not set in environment variables.")
        exit(1)

    # Run aiohttp server for webhook
    app = web.Application()
    app.router.add_post("/" + BOT_TOKEN, webhook_handler)

    import ssl
    ssl_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    ssl_context.load_cert_chain(os.getenv("SSL_CERT_PATH"), os.getenv("SSL_KEY_PATH"))

    runner = web.AppRunner(app)
    loop = asyncio.get_event_loop()

    async def start_webhook():
        await runner.setup()
        site = web.TCPSite(runner, "0.0.0.0", int(os.getenv("PORT", 8443)), ssl_context=ssl_context)
        await site.start()
        logger.info("Bot is running via webhook...")

    loop.create_task(start_webhook())
    loop.run_until_complete(application.initialize())
    loop.run_until_complete(application.start())
    loop.run_forever()
